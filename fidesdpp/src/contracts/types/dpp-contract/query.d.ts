// Generated by dedot cli

import type { GenericSubstrateApi } from 'dedot/types';
import type { FixedBytes, Result, H160 } from 'dedot/codecs';
import type {
  GenericContractQuery,
  GenericContractQueryCall,
  ContractCallOptions,
  GenericContractCallResult,
  ContractCallResult,
  MetadataType,
} from 'dedot/contracts';
import type {
  DppContractDppContractV2Granularity,
  DppContractDppContractV2Error,
  InkPrimitivesLangError,
  DppContractDppContractV2PassportRecord,
  DppContractDppContractV2VersionHistory,
} from './types.js';

export interface ContractQuery<Type extends MetadataType> extends GenericContractQuery<Type> {
  /**
   * Register a new passport
   *
   * Creates a new passport record with the provided anchor data.
   *
   * # Arguments
   *
   * * `dataset_uri` - IPFS URI (e.g., "ipfs://bafkrei...")
   * * `payload_hash` - SHA-256 hash of the JWT string
   * * `dataset_type` - MIME type (e.g., "application/vc+jwt")
   * * `granularity` - Granularity level (ProductClass, Batch, or Item)
   * * `subject_id_hash` - Optional hashed canonical subject identifier
   *
   * # Returns
   *
   * Token ID of the newly registered passport
   *
   * # Errors
   *
   * * `InvalidInput` - Empty dataset_uri or dataset_type
   *
   * @param {string} datasetUri
   * @param {FixedBytes<32>} payloadHash
   * @param {string} datasetType
   * @param {DppContractDppContractV2Granularity} granularity
   * @param {FixedBytes<32> | undefined} subjectIdHash
   * @param {ContractCallOptions} options
   *
   * @selector 0x50bc73be
   **/
  registerPassport: GenericContractQueryCall<
    (
      datasetUri: string,
      payloadHash: FixedBytes<32>,
      datasetType: string,
      granularity: DppContractDppContractV2Granularity,
      subjectIdHash: FixedBytes<32> | undefined,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<bigint, DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   * Get passport record by token ID
   *
   * # Arguments
   *
   * * `token_id` - Token ID to retrieve
   *
   * # Returns
   *
   * PassportRecord if found, None otherwise
   *
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x0ea9786c
   **/
  getPassport: GenericContractQueryCall<
    (
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<DppContractDppContractV2PassportRecord | undefined, ContractCallResult>>,
    Type
  >;

  /**
   * Update dataset (new version on IPFS)
   *
   * Updates the IPFS reference and increments version.
   * Only the original issuer can call this.
   *
   * # Arguments
   *
   * * `token_id` - Token ID to update
   * * `dataset_uri` - New IPFS URI
   * * `payload_hash` - New SHA-256 hash
   * * `dataset_type` - New MIME type
   * * `subject_id_hash` - New optional subject ID hash
   *
   * # Notes
   *
   * Granularity is IMMUTABLE after registration. If you need to change
   * granularity, revoke the old passport and register a new one.
   *
   * # Errors
   *
   * * `TokenNotFound` - Token ID doesn't exist
   * * `Unauthorized` - Caller is not the issuer
   * * `PassportRevoked` - Cannot update revoked passport
   * * `InvalidInput` - Empty dataset_uri or dataset_type
   *
   * @param {bigint} tokenId
   * @param {string} datasetUri
   * @param {FixedBytes<32>} payloadHash
   * @param {string} datasetType
   * @param {FixedBytes<32> | undefined} subjectIdHash
   * @param {ContractCallOptions} options
   *
   * @selector 0x25a2795e
   **/
  updateDataset: GenericContractQueryCall<
    (
      tokenId: bigint,
      datasetUri: string,
      payloadHash: FixedBytes<32>,
      datasetType: string,
      subjectIdHash: FixedBytes<32> | undefined,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   * Revoke a passport (irreversible)
   *
   * Sets status to Revoked. Cannot be undone.
   * Only the original issuer can call this.
   *
   * # Arguments
   *
   * * `token_id` - Token ID to revoke
   * * `reason` - Optional revocation reason (stored in event only)
   *
   * # Errors
   *
   * * `TokenNotFound` - Token ID doesn't exist
   * * `Unauthorized` - Caller is not the issuer
   * * `AlreadyRevoked` - Passport is already revoked
   *
   * @param {bigint} tokenId
   * @param {string | undefined} reason
   * @param {ContractCallOptions} options
   *
   * @selector 0xa4cec762
   **/
  revokePassport: GenericContractQueryCall<
    (
      tokenId: bigint,
      reason: string | undefined,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} owner
   * @param {ContractCallOptions} options
   *
   * @selector 0x0f755a56
   **/
  balanceOf: GenericContractQueryCall<
    (owner: H160, options?: ContractCallOptions) => Promise<GenericContractCallResult<bigint, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x99720c1e
   **/
  ownerOf: GenericContractQueryCall<
    (
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<H160 | undefined, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x27592dea
   **/
  getApproved: GenericContractQueryCall<
    (
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<H160 | undefined, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} owner
   * @param {H160} operator
   * @param {ContractCallOptions} options
   *
   * @selector 0x0f5922e9
   **/
  isApprovedForAll: GenericContractQueryCall<
    (
      owner: H160,
      operator: H160,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<boolean, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} to
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x681266a0
   **/
  approve: GenericContractQueryCall<
    (
      to: H160,
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} operator
   * @param {boolean} approved
   * @param {ContractCallOptions} options
   *
   * @selector 0xcfd0c27b
   **/
  setApprovalForAll: GenericContractQueryCall<
    (
      operator: H160,
      approved: boolean,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} to
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x84a15da1
   **/
  transfer: GenericContractQueryCall<
    (
      to: H160,
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   *
   * @param {H160} from
   * @param {H160} to
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x0b396f18
   **/
  transferFrom: GenericContractQueryCall<
    (
      from: H160,
      to: H160,
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Result<[], DppContractDppContractV2Error>, ContractCallResult>>,
    Type
  >;

  /**
   * Get next token ID (for informational purposes)
   *
   * @param {ContractCallOptions} options
   *
   * @selector 0x4bb70b15
   **/
  nextTokenId: GenericContractQueryCall<
    (options?: ContractCallOptions) => Promise<GenericContractCallResult<bigint, ContractCallResult>>,
    Type
  >;

  /**
   * Get specific version from history
   *
   * # Arguments
   *
   * * `token_id` - Token ID
   * * `version` - Version number (1-indexed)
   *
   * # Returns
   *
   * VersionHistory if found, None otherwise
   *
   * # Example
   *
   * ```ignore
   * let v1 = contract.get_version(token_id, 1); // Get original version
   * let v2 = contract.get_version(token_id, 2); // Get second version
   * ```
   *
   * @param {bigint} tokenId
   * @param {number} version
   * @param {ContractCallOptions} options
   *
   * @selector 0x0c1a1d77
   **/
  getVersion: GenericContractQueryCall<
    (
      tokenId: bigint,
      version: number,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<DppContractDppContractV2VersionHistory | undefined, ContractCallResult>>,
    Type
  >;

  /**
   * Get all version history for a passport
   *
   * Returns a vector of all versions in ascending order (v1, v2, v3, ...).
   *
   * # Arguments
   *
   * * `token_id` - Token ID
   *
   * # Returns
   *
   * Vector of VersionHistory entries (empty if token doesn't exist or has no history)
   *
   * # Note
   *
   * This iterates from version 1 up to the current version.
   * For passports with many versions, consider using get_version() for specific versions.
   *
   * @param {bigint} tokenId
   * @param {ContractCallOptions} options
   *
   * @selector 0x88721cad
   **/
  getVersionHistory: GenericContractQueryCall<
    (
      tokenId: bigint,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Array<DppContractDppContractV2VersionHistory>, ContractCallResult>>,
    Type
  >;

  /**
   * Get the latest N versions
   *
   * Useful for displaying recent history without loading all versions.
   *
   * # Arguments
   *
   * * `token_id` - Token ID
   * * `limit` - Maximum number of versions to return
   *
   * # Returns
   *
   * Vector of the most recent versions, in descending order (newest first)
   *
   * @param {bigint} tokenId
   * @param {number} limit
   * @param {ContractCallOptions} options
   *
   * @selector 0x579643a3
   **/
  getRecentVersions: GenericContractQueryCall<
    (
      tokenId: bigint,
      limit: number,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<Array<DppContractDppContractV2VersionHistory>, ContractCallResult>>,
    Type
  >;

  /**
   * Find token ID by subject identifier hash
   *
   * Enables lookup of passport by product identifier (hashed).
   * The caller must compute the hash off-chain using the same algorithm:
   * - ProductClass: SHA-256(productId)
   * - Batch: SHA-256(productId + "#" + batchNumber)
   * - Item: SHA-256(productId + "#" + serialNumber)
   *
   * # Arguments
   *
   * * `subject_id_hash` - SHA-256 hash of the canonical subject identifier
   *
   * # Returns
   *
   * Token ID if found, None otherwise
   *
   * # Example
   *
   * ```ignore
   * // Off-chain: Compute hash
   * let hash = sha256("GTIN-123#LOT-2024-001"); // Batch granularity
   *
   * // On-chain: Lookup token ID
   * let token_id = contract.find_token_by_subject_id(hash);
   * ```
   *
   * @param {FixedBytes<32>} subjectIdHash
   * @param {ContractCallOptions} options
   *
   * @selector 0xb80b21f1
   **/
  findTokenBySubjectId: GenericContractQueryCall<
    (
      subjectIdHash: FixedBytes<32>,
      options?: ContractCallOptions,
    ) => Promise<GenericContractCallResult<bigint | undefined, ContractCallResult>>,
    Type
  >;
}

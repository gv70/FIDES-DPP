'use client';

import { PendingText } from '@/components/shared/pending-text';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ContractId } from '@/contracts/deployments';
import { DppContractContractApi } from '@/contracts/types/dpp-contract';
import { shortenAddress } from '@/lib/utils';
import { useCheckMappedAccount, useContract, useContractQuery, useContractTx, useTypink, useWatchContractEvent } from 'typink';
import { useState, useEffect, useCallback, useMemo } from 'react';
import { toast } from 'sonner';
import { txToaster } from 'typink';
import { Contract } from 'dedot/contracts';
import { deployments } from '@/contracts/deployments';
import { useContractAddress } from '@/hooks/use-contract-address';
import { formatHashForContract, getIPFSGatewayURL } from '@/lib/ipfs-utils';
import { ExternalLink, CheckCircle2, Loader2 } from 'lucide-react';
import { prepareCreatePassport } from '@/app/actions/hybrid-passport-actions';
import { uploadVcJwtToIpfs } from '@/app/actions/ipfs-vc-actions';
import type { CreatePassportFormInput } from '@/lib/application/hybrid-types';

export function DppContractTest() {
  const showAdvancedUi = false;
  const { isMapped } = useCheckMappedAccount();
  const { connectedAccount, client } = useTypink();
  
  // Use hook for contract address management with localStorage
  const {
    customAddress: customContractAddress,
    useCustom: useCustomAddress,
    activeAddress,
    defaultAddress,
    setCustomAddress: setCustomContractAddress,
    setUseCustom: setUseCustomAddress,
  } = useContractAddress();
  
  // Get default contract from deployments
  const defaultContract = useContract<DppContractContractApi>(ContractId.DPP_CONTRACT);
  
  // Create custom contract instance if custom address is provided
  const customContract = useMemo(() => {
    if (!useCustomAddress || !customContractAddress || !client) return null;
    
    try {
      const deployment = deployments.find(d => d.id === ContractId.DPP_CONTRACT);
      if (!deployment) return null;
      
      // Validate address format
      if (!customContractAddress.startsWith('0x') || customContractAddress.length < 42) {
        return null;
      }
      
      return new Contract<DppContractContractApi>(
        client,
        deployment.metadata as any,
        customContractAddress as `0x${string}`
      );
    } catch (e) {
      console.error('Failed to create custom contract instance:', e);
      return null;
    }
  }, [useCustomAddress, customContractAddress, client]);
  
  // Use custom contract if available, otherwise use default
  const contract = useCustomAddress && customContract ? customContract : defaultContract.contract;
  
  // Check if contract is available
  const isContractAvailable = !!contract;
  
  // State for query inputs
  const [tokenId, setTokenId] = useState<string>('');
  const [queryAddress, setQueryAddress] = useState<string>('');

  // Set connected account as default for balance query
  useEffect(() => {
    if (connectedAccount && !queryAddress) {
      setQueryAddress(connectedAccount.address);
    }
  }, [connectedAccount, queryAddress]);
  
  // State for mint form
  const [mintForm, setMintForm] = useState({
    productId: '',
    productName: '',
    description: '',
    manufacturerName: '',
    manufacturerId: '',
    facility: '',
    country: '',
    batchNumber: '',
    serialNumber: '',
    granularity: 'Batch' as 'ProductClass' | 'Batch' | 'Item', // v0.2: granularity field
  });

  // IPFS integration state
  const [ipfsUploadResult, setIpfsUploadResult] = useState<{
    cid: string;
    hash: string; // SHA-256 hash (0x...)
    url?: string;
    size?: number;
  } | null>(null);
  const [isUploadingToIpfs, setIsUploadingToIpfs] = useState(false);

  // Query hooks - use default values when params not available
  const tokenIdNum = tokenId ? BigInt(tokenId) : BigInt(0);
  const addressForQuery = queryAddress || connectedAccount?.address || '0x0000000000000000000000000000000000000000';

  // v0.2: Use getPassport (camelCase, as generated by dedot)
  // Note: dedot converts ink! snake_case messages to camelCase
  const { data: passport, isLoading: isLoadingPassport } = useContractQuery({
    contract,
    fn: 'getPassport' as any,
    args: [tokenIdNum],
    watch: false,
  });

  // v0.2: Removed obsolete queries (getProductInfo, getManufacturer, getStatus, balanceOf, ownerOf)
  // These don't exist in v0.2 - all data is in the PassportRecord

  // Transaction state
  const [isRegistering, setIsRegistering] = useState(false);
  const [isUpdating, setIsUpdating] = useState(false);

  // Listen to PassportRegistered event to get tokenId
  useWatchContractEvent(
    contract,
    'PassportRegistered',
    useCallback((events) => {
      events.forEach((event) => {
        const { data } = event;
        if (data.tokenId) {
          const newTokenId = data.tokenId.toString();
	          toast.success(
	            <div>
	              <div>Passport created! Token ID: {newTokenId}</div>
	              <div className='text-xs mt-1'>
	                Scroll down to "Verify Passport" to view the VC-JWT
	              </div>
	            </div>,
	            { duration: 5000 }
	          );
          setTokenId(newTokenId);
          
          // Note: IPFS upload is now done automatically in handleCreatePassport
          // No need to update dataset separately
        }
      });
    }, []),
  );

  const handleCreatePassport = async () => {
    if (!contract) {
      toast.error('Contract not found. Please ensure the contract is deployed and the address is correct.');
      return;
    }

    // v0.2: Validate granularity-specific required fields
    if (mintForm.granularity === 'Batch' && !mintForm.batchNumber) {
      toast.error('Batch Number is required for Batch granularity');
      return;
    }
    if (mintForm.granularity === 'Item' && !mintForm.serialNumber) {
      toast.error('Serial Number is required for Item granularity');
      return;
    }

    // Validate required fields
    if (!mintForm.productId || !mintForm.productName || !mintForm.description || 
        !mintForm.manufacturerName || !mintForm.manufacturerId || !mintForm.facility || !mintForm.country) {
      toast.error('Please fill in all required fields');
      return;
    }

    const toaster = txToaster('Creating passport...');

    try {
      // Step 1: Generate VC-JWT and upload to IPFS (if not already done)
      let uploadResult = ipfsUploadResult;
      
      if (!uploadResult) {
        setIsUploadingToIpfs(true);
        toast.info('Generating VC-JWT and uploading to IPFS...');
        
        try {
          if (!connectedAccount) {
            throw new Error('Wallet not connected');
          }

          // Prepare form input for hybrid flow
          const formInput: CreatePassportFormInput = {
            productId: mintForm.productId,
            productName: mintForm.productName,
            productDescription: mintForm.description,
            granularity: mintForm.granularity,
            batchNumber: mintForm.batchNumber,
            serialNumber: mintForm.serialNumber,
            manufacturer: {
              name: mintForm.manufacturerName,
              identifier: mintForm.manufacturerId,
              country: mintForm.country,
              facility: mintForm.facility,
            },
            issuerAddress: connectedAccount.address,
            issuerPublicKey: (() => {
              // Try to get publicKey from connectedAccount first
              const accountPublicKey = (connectedAccount as any).publicKey;
              if (accountPublicKey && accountPublicKey instanceof Uint8Array && accountPublicKey.length === 32) {
                return `0x${Buffer.from(accountPublicKey).toString('hex')}`;
              }
              
              // Fallback: decode from SS58 address using @polkadot/util-crypto
              // This extracts the public key bytes from the address
              try {
                const { decodeAddress } = require('@polkadot/util-crypto');
                const decodedPublicKey = decodeAddress(connectedAccount.address);
                if (decodedPublicKey && decodedPublicKey.length === 32) {
                  return `0x${Buffer.from(decodedPublicKey).toString('hex')}`;
                }
              } catch (decodeError) {
                console.error('Failed to decode address to public key:', decodeError);
              }
              
              // Last resort: throw error with helpful message
              throw new Error(
                'Cannot extract public key from connected account. ' +
                'Please ensure your wallet extension is properly connected and supports ed25519 keys.'
              );
            })(),
            network: 'westend-asset-hub',
          };

          // Phase 1: Prepare (server generates VC payload, no signing)
          const prepared = await prepareCreatePassport(formInput);
          
          if ('error' in prepared) {
            throw new Error(prepared.error);
          }

          // Phase 2: Sign VC-JWT in browser
          toast.info('Signing VC-JWT with wallet...');
          const signedVcJwt = await signVcJwtInBrowser(
            prepared.vcSignablePayload.signingInput,
            prepared.preparedId
          );

          // Phase 3: Upload signed VC-JWT to IPFS
          toast.info('Uploading VC-JWT to IPFS...');
          const uploadResponse = await uploadVcJwtToIpfs(signedVcJwt, {
            name: `dpp-${mintForm.granularity}-${mintForm.productId}.jwt`,
            granularity: mintForm.granularity,
            productId: mintForm.productId,
          });

          if (!uploadResponse.success || !uploadResponse.cid || !uploadResponse.hash) {
            throw new Error(uploadResponse.error || 'Failed to upload VC-JWT to IPFS');
          }

          uploadResult = {
            cid: uploadResponse.cid,
            hash: uploadResponse.hash,
            url: uploadResponse.url,
            size: uploadResponse.size,
          };
          
          setIpfsUploadResult(uploadResult);
          toast.success('VC-JWT uploaded to IPFS successfully!');
        } catch (uploadError: any) {
          toast.error(`VC-JWT generation/upload failed: ${uploadError.message || 'Unknown error'}`);
          toaster.onTxError(uploadError);
          return;
        } finally {
          setIsUploadingToIpfs(false);
        }
      }

      // Step 2: Register on-chain
      toast.info('Registering passport on-chain...');

      // v0.2: Prepare register_passport arguments
      const datasetUri = `ipfs://${uploadResult.cid}`;
      const payloadHash = formatHashForContract(uploadResult.hash);
      
      // dedot accepts FixedBytes<32> as hex string (0x...) or Uint8Array
      // Use hex string directly (same as PolkadotChainAdapter pattern)
      const payloadHashHex = payloadHash; // Already in format "0x..."

      // Dedot encodes ink! enums from string variants (e.g. 'Batch')
      const granularity = mintForm.granularity;

      // Compute subject ID hash as hex string (matching PolkadotChainAdapter pattern)
      let subjectIdHashHex: string | undefined = undefined;
      if (mintForm.granularity === 'ProductClass') {
        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(mintForm.productId));
        const hashBytes = new Uint8Array(hash);
        subjectIdHashHex = `0x${Array.from(hashBytes).map(b => b.toString(16).padStart(2, '0')).join('')}`;
      } else if (mintForm.granularity === 'Batch' && mintForm.batchNumber) {
        const canonicalId = `${mintForm.productId}#${mintForm.batchNumber}`;
        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(canonicalId));
        const hashBytes = new Uint8Array(hash);
        subjectIdHashHex = `0x${Array.from(hashBytes).map(b => b.toString(16).padStart(2, '0')).join('')}`;
      } else if (mintForm.granularity === 'Item' && mintForm.serialNumber) {
        const canonicalId = `${mintForm.productId}#${mintForm.serialNumber}`;
        const hash = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(canonicalId));
        const hashBytes = new Uint8Array(hash);
        subjectIdHashHex = `0x${Array.from(hashBytes).map(b => b.toString(16).padStart(2, '0')).join('')}`;
      }

      // Use contract.tx API directly (bypassing useContractTx hook)
      if (!contract || !connectedAccount) {
        throw new Error('Contract or account not available');
      }

      setIsRegistering(true);
      
      // Call registerPassport using contract.tx API (camelCase, not snake_case)
      // Note: typink/dedot generates camelCase method names from ink! snake_case messages
      // Parameters: datasetUri, payloadHash (hex string), datasetType, granularity, subjectIdHash (hex string), options (last)
      // dedot expects FixedBytes<32> as hex string (0x...), not Uint8Array
      const tx = (contract as any).tx.registerPassport(
        datasetUri,
        payloadHashHex, // Hex string "0x..." - dedot will convert to [u8; 32]
        'application/vc+jwt', // v0.2: dataset_type
        granularity, // Granularity enum ('ProductClass' | 'Batch' | 'Item')
        subjectIdHashHex, // Optional: hex string "0x..." or undefined for None
        {}, // Options (last parameter) - empty object for auto-estimate
      );

      // Use callback pattern (same as PolkadotChainAdapter)
      // Extract tokenId from events and verify passport was created
      let createdTokenId: string | null = null;
      let txHash: string | number | null = null;
      
      await new Promise<void>((resolve, reject) => {
        tx.signAndSend(
          connectedAccount.address,
          async (progress: any) => {
            // Handle progress updates (pass full progress object)
            toaster.onTxProgress(progress);
            
            // Check status - dedot may use different status structure than typink
            const status = progress.status || progress;
            const dispatchError = progress.dispatchError;
            const events = progress.events || [];
            
            // Extract txHash if available
            if (progress.txHash) {
              txHash = String(progress.txHash);
            } else if (status?.asInBlock) {
              txHash = String(status.asInBlock.toHex?.() || status.asInBlock);
            } else if (status?.asFinalized) {
              txHash = String(status.asFinalized.toHex?.() || status.asFinalized);
            }
            
            // Try to extract tokenId from events
            // dedot events structure: events[] -> { event: { section, method, data } }
            for (const evt of events) {
              const event = evt.event || evt;
              console.log('Event received:', {
                section: event.section,
                method: event.method,
                data: event.data,
              });
              
              // Look for PassportRegistered event
              // Contract events are wrapped in contracts.ContractEmitted
              if (event.section === 'contracts' && event.method === 'ContractEmitted') {
                try {
                  // Event data structure: [contractAddress, contractEvent]
                  // contractEvent contains the decoded event from our contract
                  const contractEvent = event.data?.[1];
                  if (contractEvent) {
                    // Try to decode using contract ABI
                    const decoded = (contract as any)?.abi?.decodeEvent?.(contractEvent);
                    if (decoded?.event?.identifier === 'PassportRegistered') {
                      // token_id is the first argument
                      createdTokenId = decoded.args?.[0]?.toString() || decoded.args?.token_id?.toString();
                      console.log('PassportRegistered event found. Token ID:', createdTokenId);
                    }
                  }
                } catch (decodeError: any) {
                  console.warn('Failed to decode contract event:', decodeError.message);
                }
              }
            }
            
            if (status?.isInBlock || status?.isFinalized || status?.type === 'Finalized' || status?.type === 'BestChainBlockIncluded') {
              if (dispatchError) {
                let errorMessage = 'Transaction failed';
                if (dispatchError.isModule) {
                  errorMessage = `Transaction failed: ${dispatchError.toString()}`;
                } else {
                  errorMessage = `Transaction failed: ${dispatchError.toString()}`;
                }
                reject(new Error(errorMessage));
                return;
              }
              
              // Transaction successful
              resolve();
            }
          }
        ).catch((error: any) => {
          reject(error);
        });
      });

      // Verify passport was created by querying the contract
      if (createdTokenId) {
        try {
          console.log('Verifying passport creation... Token ID:', createdTokenId);
          
          // Query the contract to verify passport exists
          const queryResult = await (contract as any).query.getPassport(
            connectedAccount.address,
            {},
            BigInt(createdTokenId)
          );
          
          if (queryResult?.output) {
            const passport = queryResult.output;
	            console.log('Passport verified on-chain:', {
	              tokenId: createdTokenId,
	              datasetUri: passport.datasetUri,
	              status: passport.status,
	              version: passport.version,
	            });
            
            toast.success(
              `Passport created successfully! Token ID: ${createdTokenId}`,
              { duration: 5000 }
            );
          } else {
	            console.warn('Passport created but not found in query (may need to wait for block finalization)');
	            toast.success(
	              `Transaction submitted! Token ID: ${createdTokenId} (verifying...)`,
	              { duration: 5000 }
	            );
          }
        } catch (verifyError: any) {
          console.warn('Could not verify passport immediately:', verifyError.message);
          toast.success(
            `Transaction submitted! Token ID: ${createdTokenId || 'pending'}`,
            { duration: 5000 }
          );
        }
      } else {
        // If we couldn't extract tokenId from events, still show success
	        console.warn('Could not extract tokenId from events');
	        const hashDisplay = txHash ? ` Hash: ${String(txHash).slice(0, 10)}...` : '';
	        toast.success(
	          `Transaction submitted successfully!${hashDisplay}`,
	          { duration: 5000 }
	        );
      }
      
      // Reset form and IPFS state
      setMintForm({
        productId: '',
        productName: '',
        description: '',
        manufacturerName: '',
        manufacturerId: '',
        facility: '',
        country: '',
        batchNumber: '',
        serialNumber: '',
        granularity: 'Batch', // v0.2: reset to default
      });
      setIpfsUploadResult(null);
    } catch (e: any) {
      console.error('Create passport error:', e);
      toaster.onTxError(e);
      toast.error(e.message || 'Failed to create passport');
    } finally {
      setIsRegistering(false);
    }
  };

  const handleUpdateDataset = async (
    tokenIdStr: string, 
    uploadResult: { cid: string; hash: string; url?: string; size?: number }
  ) => {
    if (!contract) return;

    const toaster = txToaster('Updating dataset URI...');

    try {
      // Convert CID to IPFS URI format
      const ipfsUri = `ipfs://${uploadResult.cid}`;
      
      // Format hash for contract (ensure 0x prefix)
      const updatedPayloadHash = formatHashForContract(uploadResult.hash);

      // v0.2: update_dataset signature: (token_id, dataset_uri, payload_hash, dataset_type, subject_id_hash)
      // Note: subject_id_hash is optional and granularity is immutable
      // For now, we'll pass undefined for subject_id_hash (can be improved later)
      
      if (!contract || !connectedAccount) {
        throw new Error('Contract or account not available');
      }

      setIsUpdating(true);

      // Use contract.tx API directly (camelCase, not snake_case)
      // Parameters: tokenId, datasetUri, payloadHash (hex string), datasetType, subjectIdHash (hex string), options (last)
      // dedot expects FixedBytes<32> as hex string (0x...), not Uint8Array
      const tx = (contract as any).tx.updateDataset(
        BigInt(tokenIdStr),
        ipfsUri,
        updatedPayloadHash, // Hex string "0x..." - dedot will convert to [u8; 32]
        'application/vc+jwt', // v0.2: dataset_type
        undefined, // subject_id_hash (optional, can be undefined for None)
        {}, // Options (last parameter) - empty object for auto-estimate
      );

      // Use callback pattern (same as PolkadotChainAdapter)
      await new Promise<void>((resolve, reject) => {
        tx.signAndSend(
          connectedAccount.address,
          async (progress: any) => {
            // Handle progress updates (pass full progress object)
            toaster.onTxProgress(progress);
            
            // Check status - dedot may use different status structure than typink
            const status = progress.status || progress;
            const dispatchError = progress.dispatchError;
            
            if (status?.isInBlock || status?.isFinalized || status?.type === 'Finalized' || status?.type === 'BestChainBlockIncluded') {
              if (dispatchError) {
                let errorMessage = 'Transaction failed';
                if (dispatchError.isModule) {
                  errorMessage = `Transaction failed: ${dispatchError.toString()}`;
                } else {
                  errorMessage = `Transaction failed: ${dispatchError.toString()}`;
                }
                reject(new Error(errorMessage));
                return;
              }
              
              // Transaction successful
              resolve();
            }
          }
        ).catch((error: any) => {
          reject(error);
        });
      });
      
      toast.success('Dataset URI updated on-chain!');
    } catch (e: any) {
      console.error('Failed to update dataset:', e);
      toaster.onTxError(e);
    } finally {
      setIsUpdating(false);
    }
  };

  // Helper to sign VC-JWT in browser using wallet
  const signVcJwtInBrowser = async (
    signingInput: string,
    preparedId: string
  ): Promise<string> => {
    if (!connectedAccount) {
      throw new Error('No wallet connected');
    }
    
    // CRITICAL VALIDATION: Check key type before signing
    // Sr25519 is NOT compatible with EdDSA/JWT standard
    const keyType = (connectedAccount as any).type || (connectedAccount as any).meta?.type;
    
    if (keyType === 'sr25519') {
      toast.error('Sr25519 keys are NOT supported. Use ed25519 account.');
      throw new Error(
        'Sr25519 keys are NOT supported for VC-JWT signing. ' +
        'Only ed25519 is compatible with EdDSA algorithm. ' +
        'Please create a new account with ed25519 key type in Polkadot.js extension. ' +
        'See docs/KEY_TYPE_REQUIREMENTS.md for instructions.'
      );
    }
    
    // Validate public key (must be 32 bytes for ed25519)
    // Validate public key - try multiple methods
    let publicKeyBytes: Uint8Array | null = null;
    const accountWithKey = connectedAccount as any;
    
    // Method 1: Direct from connectedAccount
    if (accountWithKey.publicKey && accountWithKey.publicKey instanceof Uint8Array && accountWithKey.publicKey.length === 32) {
      publicKeyBytes = accountWithKey.publicKey;
    } else {
      // Method 2: Decode from SS58 address
      try {
        const { decodeAddress } = require('@polkadot/util-crypto');
        publicKeyBytes = decodeAddress(connectedAccount.address);
        if (!publicKeyBytes || publicKeyBytes.length !== 32) {
          throw new Error('Decoded public key has invalid length');
        }
      } catch (decodeError: any) {
        throw new Error(
          `Cannot extract public key from account: ${decodeError.message}. ` +
          `Please ensure your wallet extension is properly connected and supports ed25519 keys.`
        );
      }
    }
    
    if (!publicKeyBytes || publicKeyBytes.length !== 32) {
      throw new Error(
        `Invalid public key: expected 32 bytes for ed25519, got ${publicKeyBytes?.length || 0}. ` +
        `Ensure your account uses ed25519 keys.`
      );
    }
    
	    if (!keyType) {
	      console.warn('Key type could not be determined from extension. Assuming ed25519.');
	      toast.warning('Key type unknown - assuming ed25519. If verification fails, check your account type.');
	    } else {
	      console.log(`Key type validated: ${keyType}`);
	    }

    // Convert signing input to bytes
    const signingInputBytes = new TextEncoder().encode(signingInput);
    
    // Base64url encode helper
    const base64UrlEncode = (buf: Uint8Array): string => {
      return Buffer.from(buf)
        .toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
    };

    let signature: Uint8Array;
    
    // Try multiple methods to get signer
    try {
      // Method 1: Try using connectedAccount.sign if available (typink API)
      if ((connectedAccount as any).sign && typeof (connectedAccount as any).sign === 'function') {
        console.log('Using connectedAccount.sign() method');
        signature = await (connectedAccount as any).sign(signingInputBytes);
      }
      // Method 2: Try accessing via window.injectedWeb3 (most reliable for browser extensions)
      else if (typeof window !== 'undefined') {
        console.log('Trying to access wallet via window.injectedWeb3');
        
        // Wait a bit for extension to be ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check if injectedWeb3 is available
        if (!(window as any).injectedWeb3) {
          throw new Error('Wallet extension not detected. Please install and enable Polkadot.js extension.');
        }
        
        // Try common wallet names (in order of preference)
        const walletNames = [
          (connectedAccount as any).wallet,
          (connectedAccount as any).meta?.source,
          'polkadot-js',
          'subwallet-js',
          'talisman',
        ].filter(Boolean);

        let injected: any = null;
        let foundWalletName: string | null = null;
        
        for (const walletName of walletNames) {
          if ((window as any).injectedWeb3[walletName]) {
            injected = (window as any).injectedWeb3[walletName];
            foundWalletName = walletName;
            console.log(`Found wallet: ${walletName}`);
            break;
          }
        }

        if (!injected) {
          // List available wallets for debugging
          const availableWallets = Object.keys((window as any).injectedWeb3 || {});
          console.error('Available wallets:', availableWallets);
          throw new Error(`No compatible wallet found. Available: ${availableWallets.join(', ') || 'none'}`);
        }

        // Enable the wallet if needed
        // This is required for Polkadot.js extension to expose accounts and signer
        if (injected.enable) {
          try {
            const enabled = await injected.enable();
            console.log(`Enabled wallet: ${foundWalletName}`, enabled);
            
            // After enable, the injected object might be updated
            // Re-check for accounts and signer
            if (enabled && enabled.accounts) {
              injected.accounts = enabled.accounts;
            }
            if (enabled && enabled.signer) {
              injected.signer = enabled.signer;
            }
          } catch (enableError: any) {
            console.warn('Wallet enable failed (may already be enabled):', enableError.message);
            // Continue anyway - wallet might already be enabled
          }
        }
        
        // Log injected structure after enable
        console.log('Injected wallet structure after enable:', Object.keys(injected));

        // Get signer from injected wallet
        // Polkadot.js extension exposes signer via accounts, not directly
        let signer: any = null;
        let account: any = null;
        
        // Method A: Direct signer (some wallets)
        if (injected.signer) {
          signer = injected.signer;
          console.log('Found signer directly on injected object');
        }
        // Method B: Signer via accounts (Polkadot.js extension standard)
        // Note: Polkadot.js extension structure is: injected.accounts.get() -> accounts[] -> account.signer
        if (!signer && injected.accounts) {
          console.log('Getting signer via accounts...');
          
          // Get accounts from wallet
          let accounts: any[] = [];
          if (injected.accounts.get) {
            accounts = await injected.accounts.get();
          } else if (injected.accounts.subscribe) {
            // Some wallets use subscribe pattern
            const accountsPromise = new Promise<any[]>((resolve) => {
              const unsub = injected.accounts.subscribe((accs: any[]) => {
                resolve(accs);
                unsub();
              });
            });
            accounts = await accountsPromise;
          }
          
          console.log(`Found ${accounts.length} account(s) in wallet`);
          console.log('Account details:', accounts.map((a: any) => ({
            address: a.address,
            hasSigner: !!a.signer,
            keys: Object.keys(a),
          })));
          
          // Find the account matching our connected address
          const accountAddress = connectedAccount?.address || (connectedAccount as any)?.address;
          
          if (accountAddress) {
            account = accounts.find((acc: any) => {
              // Try different address formats
              return acc.address === accountAddress ||
                     (acc.address && accountAddress && 
                      acc.address.toLowerCase() === accountAddress.toLowerCase());
            });
          }
          
          // If no match found or no address, use first account
          if (!account && accounts.length > 0) {
            account = accounts[0];
            console.warn(`No matching account found for ${accountAddress || 'N/A'}. Using first available account: ${account.address}`);
          }
          
          if (account) {
            console.log('Using account:', account.address);
            // Get signer from account
            if (account.signer) {
              signer = account.signer;
              console.log('Found signer on account object');
            } else if (account.meta && account.meta.signer) {
              signer = account.meta.signer;
              console.log('Found signer in account.meta');
            }
          }
        }
        
        // Method C: If still no signer, try using injected.signer with account from accounts
        // This is needed for Polkadot.js extension which exposes signer at top level
        if (!signer && injected.signer) {
          if (account) {
            console.log('Creating signer wrapper using injected.signer with account context');
            signer = {
              signRaw: async (params: any) => {
                // Use account address from the account we found
                return await injected.signer.signRaw({
                  address: account.address,
                  data: params.data,
                  type: params.type || 'bytes',
                });
              },
            };
          } else if (injected.accounts) {
            // Fallback: get accounts again and use first one
            try {
              let accountsList: any[] = [];
              if (injected.accounts.get) {
                accountsList = await injected.accounts.get();
              }
              if (accountsList.length > 0) {
                console.log('Creating signer wrapper using injected.signer with first account');
                const firstAccount = accountsList[0];
                signer = {
                  signRaw: async (params: any) => {
                    return await injected.signer.signRaw({
                      address: firstAccount.address,
                      data: params.data,
                      type: params.type || 'bytes',
                    });
                  },
                };
              }
            } catch (e) {
              console.error('Failed to get accounts for signer:', e);
            }
          }
        }

        if (!signer) {
          console.error('Injected wallet structure:', Object.keys(injected));
          if (injected.accounts) {
            console.error('Accounts structure:', typeof injected.accounts, Object.keys(injected.accounts));
          }
          throw new Error('Wallet signer not available. The extension may not support raw signing. Please try a different wallet or ensure the extension is unlocked and the account is authorized.');
        }

        // Try signRaw first (preferred method)
        if (signer.signRaw) {
          console.log('Using signRaw method');
          // Use account address from signer context if available, otherwise use connectedAccount
          const signAddress = account?.address || connectedAccount?.address || (connectedAccount as any)?.address;
          const signResult = await signer.signRaw({
            address: signAddress,
            data: Buffer.from(signingInputBytes).toString('hex'),
            type: 'bytes',
          });

          // Extract signature (remove 0x prefix if present)
          const sigHex = signResult.signature.replace(/^0x/, '');
          signature = Buffer.from(sigHex, 'hex');
        }
        // Fallback to signMessage if available
        else if (signer.signMessage) {
          console.log('Using signMessage method');
          const signResult = await signer.signMessage(signingInput);
          signature = Buffer.from(signResult.signature.replace(/^0x/, ''), 'hex');
        }
        else {
          console.error('Signer methods available:', Object.keys(signer));
          throw new Error('Wallet does not support raw signing. Available methods: ' + Object.keys(signer).join(', '));
        }
      }
      // Method 3: Try using client from typink (fallback)
      else if (client) {
        console.log('Trying to use client signer');
        // typink client might have signer in a different location
        const signer = (client as any).signer || (client as any).api?.signer;
        if (signer && signer.signRaw) {
          const signResult = await signer.signRaw({
            address: connectedAccount.address,
            data: Buffer.from(signingInputBytes).toString('hex'),
            type: 'bytes',
          });
          signature = Buffer.from(signResult.signature.replace(/^0x/, ''), 'hex');
        } else {
          throw new Error('Client signer not available');
        }
      }
      else {
        throw new Error('No signing method available. Please ensure your wallet is connected and unlocked.');
      }
    } catch (signError: any) {
      console.error('Signing error:', signError);
      console.error('Connected account:', {
        address: connectedAccount?.address,
        wallet: (connectedAccount as any)?.wallet,
        meta: (connectedAccount as any)?.meta,
      });
      throw new Error(`Signing failed: ${signError.message || 'Unknown error'}. Please ensure your wallet extension is installed, unlocked, and connected.`);
    }

    // Encode signature as base64url
    const signatureB64 = base64UrlEncode(signature);
    
    // Construct signed JWT: header.payload.signature
    const signedVcJwt = `${signingInput}.${signatureB64}`;
    
    return signedVcJwt;
  };

  return (
    <div className='space-y-6'>
      <Card className='bg-gray-200/70 dark:bg-white/5 border-none shadow-none'>
        <CardHeader className='pb-4'>
          <CardTitle className='text-2xl font-medium'>Fides DPP Contract</CardTitle>
          <p className='text-sm text-muted-foreground'>Contract configuration and deployment checks</p>
        </CardHeader>
        <CardContent className='space-y-6'>
          {/* Contract Address Selection */}
          <div className='space-y-4 bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6'>
            <div className='flex items-center justify-between'>
              <div>
                <h3 className='text-lg font-semibold'>Contract Address</h3>
                <p className='text-sm text-muted-foreground'>
                  {useCustomAddress 
                    ? `Using custom contract: ${shortenAddress(activeAddress)}`
                    : `Using default contract: ${shortenAddress(defaultAddress)}`
                  }
                </p>
                {useCustomAddress && (
                  <p className='text-xs text-green-600 dark:text-green-400 mt-1'>
                    ✓ Saved in browser storage (persists across sessions)
                  </p>
                )}
              </div>
              <div className='flex items-center gap-2'>
                <input
                  type='checkbox'
                  id='use-custom-address'
                  checked={useCustomAddress}
                  onChange={(e) => {
                    setUseCustomAddress(e.target.checked);
                    if (!e.target.checked) {
                      setCustomContractAddress('');
                    }
                  }}
                  className='w-4 h-4'
                />
                <Label htmlFor='use-custom-address' className='cursor-pointer'>
                  Use Custom Address
                </Label>
              </div>
            </div>
            
            {useCustomAddress && (
              <div className='space-y-2'>
                <Label>Custom Contract Address</Label>
                <Input
                  placeholder='0x...'
                  value={customContractAddress}
                  onChange={(e) => setCustomContractAddress(e.target.value)}
                  className='font-mono text-xs'
                />
                <p className='text-xs text-muted-foreground'>
                  Enter a different contract address to test against. The contract must use the same metadata/interface. 
                  Address is automatically saved and will persist across page reloads.
                </p>
	                {customContractAddress && !customContract && (
	                  <p className='text-xs text-red-600 dark:text-red-400'>
	                    Invalid address or contract instance creation failed
	                  </p>
	                )}
                {customContract && (
                  <p className='text-xs text-green-600 dark:text-green-400'>
                    ✓ Custom contract instance created successfully
                  </p>
                )}
              </div>
            )}
          </div>

          {/* Query Section */}
          {showAdvancedUi && (
          <div className='space-y-4 bg-white/40 dark:bg-gray-950 border border-gray-200 dark:border-gray-800 rounded-lg p-6'>
            <h3 className='text-lg font-semibold'>Query Functions</h3>
            
            <div className='space-y-4'>
              <div className='space-y-2'>
                <Label>Token ID</Label>
                <Input
                  type='number'
                  placeholder='Enter token ID'
                  value={tokenId}
                  onChange={(e) => setTokenId(e.target.value)}
                />
              </div>

              {/* v0.2: Display PassportRecord data */}
              {passport && (
                <div className='grid grid-cols-2 gap-4'>
                  <div className='space-y-2'>
                    <Label>Token ID</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).tokenId ? (passport as any).tokenId.toString() : 'No data'}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2'>
                    <Label>Status</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).status ? String((passport as any).status) : 'No data'}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2'>
                    <Label>Issuer</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).issuer ? shortenAddress(String((passport as any).issuer)) : 'No data'}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2'>
                    <Label>Version</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).version !== undefined ? (passport as any).version.toString() : 'No data'}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2 col-span-2'>
                    <Label>Dataset URI</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).datasetUri ? (
                          <div className='space-y-2'>
                            <code className='text-xs break-all'>{(passport as any).datasetUri}</code>
                            {(passport as any).datasetUri.startsWith('ipfs://') && (
                              <Button
                                size='sm'
                                variant='outline'
                                onClick={() => {
                                  const cid = (passport as any).datasetUri.replace('ipfs://', '');
                                  window.open(getIPFSGatewayURL(cid), '_blank');
                                }}>
                                <ExternalLink className='w-3 h-3 mr-1' />
                                View on Gateway
                              </Button>
                            )}
                          </div>
                        ) : (
                          'No data'
                        )}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2 col-span-2'>
                    <Label>Payload Hash</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).payloadHash ? (
                          <code className='text-xs break-all'>
                            {typeof (passport as any).payloadHash === 'string' 
                              ? (passport as any).payloadHash 
                              : Array.isArray((passport as any).payloadHash)
                              ? `0x${(passport as any).payloadHash.map((b: number) => b.toString(16).padStart(2, '0')).join('')}`
                              : String((passport as any).payloadHash)}
                          </code>
                        ) : (
                          'No data'
                        )}
                      </PendingText>
                    </div>
                  </div>
                </div>
              )}

              {!passport && tokenId && (
                <div className='text-sm text-muted-foreground p-4 bg-yellow-50 dark:bg-yellow-950/20 rounded-lg'>
                  No passport found for Token ID: {tokenId}
                </div>
              )}

              {/* v0.2: Add Granularity and Subject ID Hash display */}
              {passport && (
                <div className='grid grid-cols-2 gap-4'>
                  <div className='space-y-2'>
                    <Label>Granularity (v0.2)</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).granularity ? (
                          <div className='text-sm'>
	                            <span className='font-semibold'>{String((passport as any).granularity)}</span>
	                            <p className='text-xs text-muted-foreground mt-1'>
	                              {(passport as any).granularity === 'ProductClass' && 'Product model/SKU level'}
	                              {(passport as any).granularity === 'Batch' && 'Production batch/lot'}
	                              {(passport as any).granularity === 'Item' && 'Individual serialized unit'}
	                            </p>
	                          </div>
	                        ) : (
                          <span className='text-muted-foreground'>Not available (v0.1 contract)</span>
                        )}
                      </PendingText>
                    </div>
                  </div>

                  <div className='space-y-2'>
                    <Label>Subject ID Hash (v0.2)</Label>
                    <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[60px]'>
                      <PendingText isLoading={isLoadingPassport}>
                        {(passport as any).subjectIdHash ? (
                          <code className='text-xs break-all'>
                            {typeof (passport as any).subjectIdHash === 'string' 
                              ? (passport as any).subjectIdHash 
                              : Array.isArray((passport as any).subjectIdHash)
                              ? `0x${(passport as any).subjectIdHash.map((b: number) => b.toString(16).padStart(2, '0')).join('')}`
                              : 'Invalid format'}
                          </code>
                        ) : (
                          <span className='text-muted-foreground'>Not set</span>
                        )}
                      </PendingText>
                    </div>
                  </div>
                </div>
              )}

              <div className='space-y-2'>
                <Label>Full Passport Data</Label>
                <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[100px] max-h-[300px] overflow-auto'>
                  <PendingText isLoading={isLoadingPassport}>
                    {passport ? (
                      <pre className='text-xs'>{JSON.stringify(passport, (key, value) => 
                        typeof value === 'bigint' ? value.toString() : value
                      , 2)}</pre>
                    ) : (
                      'No data'
                    )}
                  </PendingText>
                </div>
              </div>
            </div>
          </div>
          )}

          {/* Transaction Section */}
          {showAdvancedUi && (
          <div className='space-y-4 bg-white/40 dark:bg-gray-950 border border-gray-200 dark:border-gray-800 rounded-lg p-6'>
	            <h3 className='text-lg font-semibold'>Create Passport (v0.2 - register_passport)</h3>
	            <p className='text-xs text-muted-foreground mb-4'>
	              v0.2 requires IPFS upload. Enable IPFS and upload passport data before creating.
	            </p>
            
            {/* v0.2: Granularity Selector */}
            <div className='space-y-4 bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4'>
              <div className='space-y-2'>
                <Label className='text-sm font-semibold'>Granularity Level (v0.2) *</Label>
                <p className='text-xs text-muted-foreground'>
                  Choose the level of specificity for this passport (aligned with UNTP and ESPR Article 10):
                </p>
                <div className='grid grid-cols-3 gap-2'>
                  <button
                    type='button'
                    onClick={() => setMintForm({ ...mintForm, granularity: 'ProductClass' })}
                    className={`p-3 rounded-lg border-2 transition-colors ${
                      mintForm.granularity === 'ProductClass'
                        ? 'border-blue-600 bg-blue-100 dark:bg-blue-900/30'
                        : 'border-gray-300 dark:border-gray-700 hover:border-blue-400'
                    }`}>
                    <div className='font-semibold text-sm'>Product Class</div>
                    <div className='text-xs text-muted-foreground'>Model/SKU level</div>
                  </button>
                  <button
                    type='button'
                    onClick={() => setMintForm({ ...mintForm, granularity: 'Batch' })}
                    className={`p-3 rounded-lg border-2 transition-colors ${
                      mintForm.granularity === 'Batch'
                        ? 'border-blue-600 bg-blue-100 dark:bg-blue-900/30'
                        : 'border-gray-300 dark:border-gray-700 hover:border-blue-400'
                    }`}>
                    <div className='font-semibold text-sm'>Batch</div>
                    <div className='text-xs text-muted-foreground'>Production lot</div>
                  </button>
                  <button
                    type='button'
                    onClick={() => setMintForm({ ...mintForm, granularity: 'Item' })}
                    className={`p-3 rounded-lg border-2 transition-colors ${
                      mintForm.granularity === 'Item'
                        ? 'border-blue-600 bg-blue-100 dark:bg-blue-900/30'
                        : 'border-gray-300 dark:border-gray-700 hover:border-blue-400'
                    }`}>
                    <div className='font-semibold text-sm'>Item</div>
                    <div className='text-xs text-muted-foreground'>Serialized unit</div>
                  </button>
	                </div>
	                <p className='text-xs text-amber-600 dark:text-amber-400'>
	                  Granularity is <strong>immutable</strong> after registration.
	                </p>
              </div>
            </div>

            <div className='grid grid-cols-2 gap-4'>
              <div className='space-y-2'>
                <Label>Product ID *</Label>
                <Input
                  value={mintForm.productId}
                  onChange={(e) => setMintForm({ ...mintForm, productId: e.target.value })}
                  placeholder='e.g., GTIN: 0123456789012'
                />
              </div>
              <div className='space-y-2'>
                <Label>Product Name *</Label>
                <Input
                  value={mintForm.productName}
                  onChange={(e) => setMintForm({ ...mintForm, productName: e.target.value })}
                  placeholder='e.g., Wood Table'
                />
              </div>
              <div className='space-y-2 col-span-2'>
                <Label>Description *</Label>
                <Input
                  value={mintForm.description}
                  onChange={(e) => setMintForm({ ...mintForm, description: e.target.value })}
                  placeholder='Product description'
                />
              </div>
              <div className='space-y-2'>
                <Label>Manufacturer Name *</Label>
                <Input
                  value={mintForm.manufacturerName}
                  onChange={(e) => setMintForm({ ...mintForm, manufacturerName: e.target.value })}
                  placeholder='e.g., Oak Furniture Co'
                />
              </div>
              <div className='space-y-2'>
                <Label>Manufacturer ID *</Label>
                <Input
                  value={mintForm.manufacturerId}
                  onChange={(e) => setMintForm({ ...mintForm, manufacturerId: e.target.value })}
                  placeholder='e.g., VAT-123456'
                />
              </div>
              <div className='space-y-2'>
                <Label>Facility *</Label>
                <Input
                  value={mintForm.facility}
                  onChange={(e) => setMintForm({ ...mintForm, facility: e.target.value })}
                  placeholder='Facility name'
                />
              </div>
              <div className='space-y-2'>
                <Label>Country *</Label>
                <Input
                  value={mintForm.country}
                  onChange={(e) => setMintForm({ ...mintForm, country: e.target.value })}
                  placeholder='e.g., US (ISO 3166-1 alpha-2)'
                />
              </div>
              <div className='space-y-2'>
                <Label>
                  Batch Number {mintForm.granularity === 'Batch' && <span className='text-red-500'>*</span>}
                </Label>
                <Input
                  value={mintForm.batchNumber}
                  onChange={(e) => setMintForm({ ...mintForm, batchNumber: e.target.value })}
                  placeholder={
                    mintForm.granularity === 'Batch'
                      ? 'Required for Batch granularity'
                      : 'Leave empty if not applicable'
                  }
                  className={
                    mintForm.granularity === 'Batch' && !mintForm.batchNumber
                      ? 'border-red-500'
                      : ''
                  }
                />
                {mintForm.granularity === 'Batch' && (
                  <p className='text-xs text-muted-foreground'>
                    Required for Batch level. Used to compute subject ID hash.
                  </p>
                )}
              </div>
              <div className='space-y-2'>
                <Label>
                  Serial Number {mintForm.granularity === 'Item' && <span className='text-red-500'>*</span>}
                </Label>
                <Input
                  value={mintForm.serialNumber}
                  onChange={(e) => setMintForm({ ...mintForm, serialNumber: e.target.value })}
                  placeholder={
                    mintForm.granularity === 'Item'
                      ? 'Required for Item granularity'
                      : 'Leave empty if not applicable'
                  }
                  className={
                    mintForm.granularity === 'Item' && !mintForm.serialNumber
                      ? 'border-red-500'
                      : ''
                  }
                />
                {mintForm.granularity === 'Item' && (
                  <p className='text-xs text-muted-foreground'>
                    Required for Item level. Used to compute subject ID hash.
                  </p>
                )}
              </div>
            </div>

            {/* IPFS Upload Status (if already uploaded) */}
            {ipfsUploadResult && (
              <div className='space-y-2 p-4 bg-green-50 dark:bg-green-950/20 border border-green-200 dark:border-green-800 rounded-lg'>
                <div className='flex items-center gap-2 text-green-700 dark:text-green-300'>
                  <CheckCircle2 className='w-4 h-4' />
                  <span className='text-sm font-medium'>IPFS Upload Complete</span>
                </div>
                <div className='text-xs text-green-600 dark:text-green-400 space-y-1'>
                  <div>
                    <strong>CID:</strong>{' '}
                    <code className='bg-green-100 dark:bg-green-900 px-1 py-0.5 rounded'>
                      {ipfsUploadResult.cid}
                    </code>
                  </div>
                  <div>
                    <strong>Size:</strong> {ipfsUploadResult.size} bytes
                  </div>
                </div>
              </div>
            )}

            <Button
              size='lg'
              disabled={
                isRegistering || 
                isUploadingToIpfs ||
                !contract || 
                !isMapped ||
                !connectedAccount ||
                !mintForm.productId || 
                !mintForm.productName || 
                !mintForm.description ||
                !mintForm.manufacturerName ||
                !mintForm.manufacturerId ||
                !mintForm.facility ||
                !mintForm.country ||
                (mintForm.granularity === 'Batch' && !mintForm.batchNumber) ||
                (mintForm.granularity === 'Item' && !mintForm.serialNumber)
              }
              onClick={handleCreatePassport}
              className='w-full bg-blue-600 hover:bg-blue-700 text-white'>
              {isUploadingToIpfs ? (
                <>
                  <Loader2 className='w-4 h-4 mr-2 animate-spin' />
                  Generating VC-JWT & Uploading to IPFS...
                </>
              ) : isRegistering ? (
                <>
                  <Loader2 className='w-4 h-4 mr-2 animate-spin' />
                  Registering on-chain...
                </>
              ) : ipfsUploadResult ? (
                'Create Passport (VC-JWT ready)'
              ) : (
                'Create Passport (will generate VC-JWT & upload to IPFS)'
              )}
            </Button>
            
            <p className='text-xs text-muted-foreground text-center mt-2'>
              {ipfsUploadResult 
                ? '✓ VC-JWT (UNTP-compliant) already on IPFS. Click to register on-chain.'
                : 'This will generate a UNTP-compliant VC-JWT, upload to IPFS, then register on-chain.'}
            </p>
            
            {isMapped === false && (
              <p className='text-sm text-muted-foreground'>Connect and map your account to create passports!</p>
            )}

	            {tokenId && (
	              <div className='mt-4 p-4 bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 rounded-lg'>
	                <p className='text-sm font-medium text-blue-900 dark:text-blue-100 mb-2'>
	                  Passport created (Token ID: {tokenId})
	                </p>
                <p className='text-xs text-blue-700 dark:text-blue-300 mb-3'>
                  To view the Verifiable Credential (VC-JWT), scroll down to the <strong>"Verify Passport (v0.2)"</strong> section 
                  and enter this Token ID to see the full VC with decoded payload.
                </p>
                <Button
                  size='sm'
                  variant='outline'
                  onClick={() => {
                    // Scroll to verify section
                    const verifySection = document.getElementById('verify-passport-section');
                    if (verifySection) {
                      verifySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
	                  }}
	                  className='w-full'>
	                  Go to Verify Passport
	                </Button>
	              </div>
	            )}
          </div>
          )}

          {/* IPFS Dataset Management Section */}
          {passport && (
            <div className='space-y-4 bg-white/40 dark:bg-gray-950 border border-gray-200 dark:border-gray-800 rounded-lg p-6'>
              <h3 className='text-lg font-semibold'>IPFS Dataset Management</h3>
              
              <div className='space-y-4'>
                <div className='space-y-2'>
                  <Label>Current Dataset URI</Label>
                  <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[40px]'>
                    {(passport as any).datasetUri ? (
                      <div className='space-y-2'>
                        <code className='text-xs break-all'>{(passport as any).datasetUri}</code>
                        <div className='flex gap-2'>
                          <Button
                            size='sm'
                            variant='outline'
                            onClick={() => {
                              const datasetUri = (passport as any).datasetUri;
                              const url = datasetUri?.startsWith('ipfs://')
                                ? getIPFSGatewayURL(datasetUri.replace('ipfs://', ''))
                                : datasetUri;
                              window.open(url, '_blank');
                            }}
                          >
                            <ExternalLink className='w-4 h-4 mr-1' />
                            View on Gateway
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <p className='text-sm text-muted-foreground'>No dataset URI set</p>
                    )}
                  </div>
                </div>

                <div className='space-y-2'>
                  <Label>Payload Hash</Label>
                  <div className='bg-gray-50 dark:bg-gray-900 rounded p-3 min-h-[40px]'>
                    {(passport as any).payloadHash ? (
                      <code className='text-xs break-all'>
                        {typeof (passport as any).payloadHash === 'string' 
                          ? (passport as any).payloadHash 
                          : Array.isArray((passport as any).payloadHash)
                          ? `0x${(passport as any).payloadHash.map((b: number) => b.toString(16).padStart(2, '0')).join('')}`
                          : String((passport as any).payloadHash)}
                      </code>
                    ) : (
                      <p className='text-sm text-muted-foreground'>No hash set</p>
                    )}
                  </div>
                </div>

                {!(passport as any).datasetUri && (
                  <div className='space-y-2 border-t pt-4'>
                    <Label>Update Dataset</Label>
                    <p className='text-xs text-muted-foreground'>
                      To update the dataset, use the "Update Dataset" section below with a new IPFS upload.
                    </p>
                  </div>
                )}
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}

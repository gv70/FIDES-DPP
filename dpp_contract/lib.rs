//! # Fides - Digital Product Passport contract - v0.1
//!
//! DPP implementation. Handles passport registration/retrieval
//! with NFT-based ownership model. Authority system separates product ownership from
//! data control (manufacturer keeps update rights even after product sale).
//!
//! Targets EU Reg 2024/1781 and UNTP core requirements.
//! 
//! TODO: Full UNTP compliance in later versions

#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod dpp_contract {
    use ink::prelude::string::{String, ToString};
    use ink::prelude::vec::Vec;
    use ink::storage::Mapping;
    use scale::{Decode, Encode};

    pub type TokenId = u128;
    // note: Timestamp is auto-generated by ink! contract macro
    // using Address type for accounts (ink v6 uses H160 internally)

    // Core data structures for DPP

    #[derive(Encode, Decode, Clone, Debug, PartialEq)]
    #[cfg_attr(
        feature = "std",
        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)
    )]
    pub struct ProductInfo {
        pub product_id: String,      // Unique ID (use URI format)
        pub name: String,
        pub description: String,
        pub category: String,
        pub batch_number: Option<String>,
        pub serial_number: Option<String>,
        pub production_date: Timestamp,
    }

    #[derive(Encode, Decode, Clone, Debug, PartialEq)]
    #[cfg_attr(
        feature = "std",
        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)
    )]
    pub struct Manufacturer {
        pub name: String,
        pub identifier: String,       // VAT, registration number, etc
        pub country: String,           // to be compliatn with ISO 3166-1 alpha-2
        pub facility: Option<String>,
    }

    #[derive(Encode, Decode, Clone, Debug, PartialEq)]
    #[cfg_attr(
        feature = "std",
        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)
    )]
    pub struct MaterialEntry {
        pub name: String,
        pub mass_fraction: u32,        // scaled by 10^6 (0-1000000 = 0.0-1.0)
        pub origin_country: Option<String>,
        pub hazardous: bool,
    }

    /// Digital Product Passport structure
    #[derive(Encode, Decode, Clone, Debug, PartialEq)]
    #[cfg_attr(
        feature = "std",
        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)
    )]
    pub struct DigitalProductPassport {
        pub product: ProductInfo,
        pub manufacturer: Manufacturer,
        pub materials: Vec<MaterialEntry>,
        pub created_at: Timestamp,
        pub updated_at: Timestamp,
        pub status: PassportStatus,
    }

    /// Passport status enumeration
    #[derive(Encode, Decode, Clone, Debug, PartialEq)]
    #[cfg_attr(
        feature = "std",
        derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)
    )]
    pub enum PassportStatus {
        Active,
        Suspended,
        Revoked,
    }

    #[derive(Debug, PartialEq, Eq, Clone)]
    #[ink::scale_derive(Encode, Decode, TypeInfo)]
    pub enum Error {
        NotOwner,
        NotApproved,
        TokenExists,
        TokenNotFound,
        CannotInsert,
        CannotFetchValue,
        NotAllowed,
        InvalidInput,
        PassportRevoked,
        Unauthorized,
    }

    pub type Result<T> = core::result::Result<T, Error>;

    // Events for DPP operations
    
    #[ink(event)]
    pub struct PassportRegistered {
        #[ink(topic)]
        token_id: TokenId,
        #[ink(topic)]
        owner: Address,
        #[ink(topic)]
        product_id: String,
        timestamp: Timestamp,
    }

    #[ink(event)]
    pub struct PassportUpdated {
        #[ink(topic)]
        token_id: TokenId,
        #[ink(topic)]
        updated_by: Address,
        timestamp: Timestamp,
    }

    #[ink(event)]
    pub struct PassportRevoked {
        #[ink(topic)]
        token_id: TokenId,
        #[ink(topic)]
        revoked_by: Address,
        timestamp: Timestamp,
    }

    // NFT standard events (ERC-721 compat)
    
    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        from: Option<Address>,
        #[ink(topic)]
        to: Option<Address>,
        #[ink(topic)]
        token_id: TokenId,
    }

    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        owner: Address,
        #[ink(topic)]
        approved: Address,
        #[ink(topic)]
        token_id: TokenId,
    }

    #[ink(event)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        owner: Address,
        #[ink(topic)]
        operator: Address,
        approved: bool,
    }


    #[ink(storage)]
    pub struct DppContract {
        // NFT ownership tracking (product ownership)
        token_owner: Mapping<TokenId, Address>,
        token_approvals: Mapping<TokenId, Address>,
        owned_tokens_count: Mapping<Address, u128>,
        operator_approvals: Mapping<(Address, Address), ()>,
        
        // DPP data storage
        passport_data: Mapping<TokenId, DigitalProductPassport>,
        next_token_id: TokenId,
        
        // Authority model - manufacturer keeps data control even after product sale
        admin: Address,
        dpp_authority: Mapping<TokenId, Address>,  // who can update passport data
    }

    impl DppContract {
        #[ink(constructor)]
        pub fn new() -> Self {
            let caller = Self::env().caller();
            Self {
                token_owner: Mapping::default(),
                token_approvals: Mapping::default(),
                owned_tokens_count: Mapping::default(),
                operator_approvals: Mapping::default(),
                passport_data: Mapping::default(),
                next_token_id: 1,
                admin: caller,
                dpp_authority: Mapping::default(),
            }
        }

        // ===== Core DPP functions =====

        /// Register new DPP - mints NFT and stores passport data
        #[ink(message)]
        pub fn register_passport(&mut self, passport: DigitalProductPassport) -> Result<TokenId> {
            let caller = self.env().caller();
            let token_id = self.next_token_id;
            let timestamp = self.env().block_timestamp();

            // quick validation
            if passport.product.name.is_empty() || passport.product.product_id.is_empty() {
                return Err(Error::InvalidInput);
            }

            self.add_token_to(&caller, token_id)?;
            self.dpp_authority.insert(token_id, &caller);  // caller becomes manufacturer/authority
            self.passport_data.insert(token_id, &passport);

            self.next_token_id = self.next_token_id
                .checked_add(1)
                .ok_or(Error::CannotInsert)?;

            self.env().emit_event(PassportRegistered {
                token_id,
                owner: caller,
                product_id: passport.product.product_id.clone(),
                timestamp,
            });

            self.env().emit_event(Transfer {
                from: None,
                to: Some(caller),
                token_id,
            });

            Ok(token_id)
        }

        /// Simplified mint function for testing - creates DPP with minimal required fields
        /// Usefull for CLI testing without having to construct the full struct
        #[ink(message)]
        pub fn mint_simple(
            &mut self,
            product_id: String,
            product_name: String,
            description: String,
            manufacturer_name: String,
            manufacturer_id: String,
            facility: String,
            country: String,
            batch_number: String,
            serial_number: String,
        ) -> Result<TokenId> {
            let timestamp = self.env().block_timestamp();

            // convert empty strings to None for Option<String> fields
            let batch = (!batch_number.is_empty()).then_some(batch_number);
            let serial = (!serial_number.is_empty()).then_some(serial_number);

            // build minimal passport struct
            let passport = DigitalProductPassport {
                product: ProductInfo {
                    product_id: product_id.clone(),
                    name: product_name,
                    description,
                    category: "General".to_string(),
                    batch_number: batch,
                    serial_number: serial,
                    production_date: timestamp,
                },
                manufacturer: Manufacturer {
                    name: manufacturer_name,
                    identifier: manufacturer_id,
                    country,
                    facility: Some(facility),
                },
                materials: Vec::new(),  // can be added later via update
                created_at: timestamp,
                updated_at: timestamp,
                status: PassportStatus::Active,
            };

            // reuse the main registration logic
            self.register_passport(passport)
        }

        /// Get passport data by token ID
        #[ink(message)]
        pub fn read_passport(&self, token_id: TokenId) -> Option<DigitalProductPassport> {
            self.passport_data.get(token_id)
        }

        /// Update passport - only authority or authorized updaters can do this
        #[ink(message)]
        pub fn update_passport(
            &mut self,
            token_id: TokenId,
            passport: DigitalProductPassport,
        ) -> Result<()> {
            let caller = self.env().caller();
            let timestamp = self.env().block_timestamp();

            // check authority
            if !self.can_update_dpp(caller, token_id) {
                return Err(Error::Unauthorized);
            }

            let current = self.passport_data.get(token_id).ok_or(Error::TokenNotFound)?;
            if current.status == PassportStatus::Revoked {
                return Err(Error::PassportRevoked);
            }

            if passport.product.name.is_empty() || passport.product.product_id.is_empty() {
                return Err(Error::InvalidInput);
            }

            let mut updated_passport = passport;
            updated_passport.updated_at = timestamp;

            self.passport_data.insert(token_id, &updated_passport);

            self.env().emit_event(PassportUpdated {
                token_id,
                updated_by: caller,
                timestamp,
            });

            Ok(())
        }

        /// Revoke/burn passport - only authority can do this
        /// Marks passport as revoked and burns the NFT
        /// Data stays on-chain for audit trail
        #[ink(message)]
        pub fn revoke_passport(&mut self, token_id: TokenId) -> Result<()> {
            let caller = self.env().caller();
            let timestamp = self.env().block_timestamp();

            // Check authority (not ownership!)
            if !self.can_update_dpp(caller, token_id) {
                return Err(Error::Unauthorized);
            }

            let owner = self.token_owner.get(token_id).ok_or(Error::TokenNotFound)?;

            // mark as revoked but keep data on-chain for audit trail
            if let Some(mut passport) = self.passport_data.get(token_id) {
                passport.status = PassportStatus::Revoked;
                passport.updated_at = timestamp;
                self.passport_data.insert(token_id, &passport);
            }

            // burn the NFT
            let count = self.owned_tokens_count
                .get(owner)
                .unwrap_or(0)
                .checked_sub(1)
                .ok_or(Error::CannotFetchValue)?;
            self.owned_tokens_count.insert(owner, &count);
            self.token_owner.remove(token_id);
            self.clear_approval(token_id);

            // Emit events
            self.env().emit_event(PassportRevoked {
                token_id,
                revoked_by: caller,
                timestamp,
            });

            self.env().emit_event(Transfer {
                from: Some(owner),
                to: None,
                token_id,
            });

            Ok(())
        }

        // ====================================================================
        // ADDITIONAL QUERY FUNCTIONS
        // ====================================================================

        /// Get product information
        #[ink(message)]
        pub fn get_product_info(&self, token_id: TokenId) -> Option<ProductInfo> {
            self.passport_data.get(token_id).map(|p| p.product)
        }

        /// Get manufacturer information
        #[ink(message)]
        pub fn get_manufacturer(&self, token_id: TokenId) -> Option<Manufacturer> {
            self.passport_data.get(token_id).map(|p| p.manufacturer)
        }

        /// Get materials composition
        #[ink(message)]
        pub fn get_materials(&self, token_id: TokenId) -> Vec<MaterialEntry> {
            self.passport_data
                .get(token_id)
                .map(|p| p.materials)
                .unwrap_or_default()
        }

        /// Get passport status
        #[ink(message)]
        pub fn get_status(&self, token_id: TokenId) -> Option<PassportStatus> {
            self.passport_data.get(token_id).map(|p| p.status)
        }

        // ====================================================================
        // NFT STANDARD FUNCTIONS (ERC-721 Compatible)
        // ====================================================================

        /// Returns the number of tokens owned by an account
        #[ink(message)]
        pub fn balance_of(&self, owner: Address) -> u128 {
            self.owned_tokens_count.get(owner).unwrap_or(0)
        }

        /// Returns the owner of a token
        #[ink(message)]
        pub fn owner_of(&self, token_id: TokenId) -> Option<Address> {
            self.token_owner.get(token_id)
        }

        /// Returns the approved account for a token
        #[ink(message)]
        pub fn get_approved(&self, token_id: TokenId) -> Option<Address> {
            self.token_approvals.get(token_id)
        }

        /// Check if operator is approved for all tokens of owner
        #[ink(message)]
        pub fn is_approved_for_all(&self, owner: Address, operator: Address) -> bool {
            self.operator_approvals.contains((&owner, &operator))
        }

        /// Approve an account to transfer a specific token
        #[ink(message)]
        pub fn approve(&mut self, to: Address, token_id: TokenId) -> Result<()> {
            let caller = self.env().caller();
            let owner = self.owner_of(token_id).ok_or(Error::TokenNotFound)?;

            if !(owner == caller || self.is_approved_for_all(owner, caller)) {
                return Err(Error::NotAllowed);
            }

            if self.token_approvals.contains(token_id) {
                self.token_approvals.remove(token_id);
            }
            self.token_approvals.insert(token_id, &to);

            self.env().emit_event(Approval {
                owner: caller,
                approved: to,
                token_id,
            });

            Ok(())
        }

        /// Set approval for all tokens
        #[ink(message)]
        pub fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<()> {
            let caller = self.env().caller();

            if operator == caller {
                return Err(Error::NotAllowed);
            }

            self.env().emit_event(ApprovalForAll {
                owner: caller,
                operator,
                approved,
            });

            if approved {
                self.operator_approvals.insert((&caller, &operator), &());
            } else {
                self.operator_approvals.remove((&caller, &operator));
            }

            Ok(())
        }

        /// Transfer token from caller to destination
        #[ink(message)]
        pub fn transfer(&mut self, to: Address, token_id: TokenId) -> Result<()> {
            let caller = self.env().caller();
            self.transfer_token_from(&caller, &to, token_id)?;
            Ok(())
        }

        /// Transfer token from one account to another (requires approval)
        #[ink(message)]
        pub fn transfer_from(
            &mut self,
            from: Address,
            to: Address,
            token_id: TokenId,
        ) -> Result<()> {
            self.transfer_token_from(&from, &to, token_id)?;
            Ok(())
        }

        // ====================================================================
        // ADMIN FUNCTIONS
        // ====================================================================

        /// Get contract admin address
        #[ink(message)]
        pub fn get_admin(&self) -> Address {
            self.admin
        }

        /// Get next token ID to be minted
        #[ink(message)]
        pub fn get_next_token_id(&self) -> TokenId {
            self.next_token_id
        }

        /// Get contract version
        #[ink(message)]
        pub fn version(&self) -> String {
            String::from("0.1.0")
        }

        // ====================================================================
        // Authority Query (M1 - Basic)
        // ====================================================================

        /// Get DPP authority - who can update passport data
        #[ink(message)]
        pub fn get_dpp_authority(&self, token_id: TokenId) -> Option<Address> {
            self.dpp_authority.get(token_id)
        }

        // ====================================================================
        // Internal Helpers
        // ====================================================================

        fn transfer_token_from(
            &mut self,
            from: &Address,
            to: &Address,
            token_id: TokenId,
        ) -> Result<()> {
            let caller = self.env().caller();
            let owner = self.owner_of(token_id).ok_or(Error::TokenNotFound)?;

            if !self.approved_or_owner(caller, token_id, owner) {
                return Err(Error::NotApproved);
            }

            if owner != *from {
                return Err(Error::NotOwner);
            }

            self.clear_approval(token_id);
            self.remove_token_from(from, token_id)?;
            self.add_token_to(to, token_id)?;

            self.env().emit_event(Transfer {
                from: Some(*from),
                to: Some(*to),
                token_id,
            });

            Ok(())
        }

        fn remove_token_from(&mut self, from: &Address, token_id: TokenId) -> Result<()> {
            if !self.token_owner.contains(token_id) {
                return Err(Error::TokenNotFound);
            }

            let count = self.owned_tokens_count
                .get(from)
                .unwrap_or(0)
                .checked_sub(1)
                .ok_or(Error::CannotFetchValue)?;
            self.owned_tokens_count.insert(from, &count);
            self.token_owner.remove(token_id);

            Ok(())
        }

        fn add_token_to(&mut self, to: &Address, token_id: TokenId) -> Result<()> {
            if self.token_owner.contains(token_id) {
                return Err(Error::TokenExists);
            }

            let count = self.owned_tokens_count
                .get(to)
                .unwrap_or(0)
                .checked_add(1)
                .ok_or(Error::CannotInsert)?;

            self.owned_tokens_count.insert(to, &count);
            self.token_owner.insert(token_id, to);

            Ok(())
        }

        fn clear_approval(&mut self, token_id: TokenId) {
            self.token_approvals.remove(token_id);
        }

        fn approved_or_owner(
            &self,
            caller: Address,
            token_id: TokenId,
            owner: Address,
        ) -> bool {
            caller == owner
                || self.token_approvals.get(token_id) == Some(caller)
                || self.is_approved_for_all(owner, caller)
        }

        // Check if caller can update DPP - basic authority check (M1)
        fn can_update_dpp(&self, caller: Address, token_id: TokenId) -> bool {
            // Check if caller is the DPP authority
            if let Some(authority) = self.dpp_authority.get(token_id) {
                if caller == authority {
                    return true;
                }
            }

            // admin for emergency access only
            if caller == self.admin {
                return true;
            }

            false
        }
    }
}
